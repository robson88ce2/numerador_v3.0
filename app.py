from datetime import datetime
import os
import time
import unicodedata
import re
import streamlit as st
import psycopg2
import pandas as pd
from contextlib import closing
from psycopg2 import pool


db_pool = None

def init_db_pool():
    """Inicializa o pool de conex√µes, se ainda n√£o foi inicializado"""
    global db_pool
    if db_pool is None:
        try:
            db_pool = psycopg2.pool.SimpleConnectionPool(
                1, 5,  # M√≠nimo 1, M√°ximo 5 (ajuste conforme necess√°rio)
                dbname=os.getenv("PG_DB", "db_z0bb"),
                user=os.getenv("PG_USER", "db_z0bb_user"),
                password=os.getenv("PG_PASS", "Tur9VycRGOxEMtHCtrjfXZFBolw2gtjS"),
                host=os.getenv("PG_HOST", "dpg-cuou4jl2ng1s73ecudj0-a.oregon-postgres.render.com"),
                port=os.getenv("PG_PORT", "5432"),
                sslmode="require",
                connect_timeout=10
            )
        except Exception as e:
            st.error(f"Erro ao inicializar o pool de conex√µes: {e}")

init_db_pool()  # Garante que o pool √© inicializado no in√≠cio

def get_db_connection():
    """Obt√©m uma conex√£o do pool"""
    global db_pool
    if db_pool is None:
        st.error("O pool de conex√µes n√£o foi inicializado corretamente.")
        return None

    try:
        conn = db_pool.getconn()
        if conn is None:
            st.error("Erro: Pool de conex√µes esgotado. Tente novamente mais tarde.")
        return conn
    except Exception as e:
        st.error(f"Erro ao obter conex√£o: {e}")
        return None

def release_db_connection(conn):
    """Libera uma conex√£o de volta para o pool"""
    global db_pool
    if conn and db_pool:
        try:
            db_pool.putconn(conn)
        except Exception as e:
            st.error(f"Erro ao liberar conex√£o: {e}")

def execute_query(query, params=None, fetch=False):
    """Executa uma query no banco de dados"""
    conn = get_db_connection()
    if conn is None:
        return None

    try:
        with conn.cursor() as cursor:
            cursor.execute(query, params or ())
            if fetch:
                result = cursor.fetchall()
                return result
            conn.commit()
    except psycopg2.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return None
    finally:
        release_db_connection(conn)  # Libera a conex√£o ap√≥s o uso


# Fun√ß√£o para normalizar o nome da sequ√™ncia
def normalizar_nome(nome):
    return nome.replace(" ", "_").replace("-", "_").lower()

# Fun√ß√£o para executar queries no banco de dados
def execute_query(query, params=None, fetch=False):
    try:
        with closing(get_db_connection()) as conn:
            with conn.cursor() as cursor:
                cursor.execute(query, params or ())
                if fetch:
                    return cursor.fetchall()
                conn.commit()
    except psycopg2.Error as e:
        st.error(f"Erro no banco de dados: {e}")
        return None

# Fun√ß√£o para formatar a data para o padr√£o que o PostgreSQL aceita (YYYY-MM-DD)
def formatar_data(data_str):
    try:
        data_obj = datetime.strptime(data_str, "%d/%m/%Y")
        return data_obj.strftime("%Y-%m-%d")  # Formata para YYYY-MM-DD
    except ValueError:
        return None  # Retorna None caso n√£o consiga converter a data

# Fun√ß√£o para criar √≠ndices no banco de dados
def create_indexes():
    execute_query("""
        CREATE INDEX IF NOT EXISTS idx_documentos_tipo ON documentos(tipo);
        CREATE INDEX IF NOT EXISTS idx_documentos_data_emissao ON documentos(data_emissao);
    """)

# Criar tabelas e sequ√™ncias se n√£o existirem
def create_tables():
    tipos = [
        "OFICIO", "CARTA_PRECATORIA", "DESPACHO", "PROTOCOLO", "ORDEM_DE_MISSAO", 
        "RELATORIO_POLICIAL", "VERIFICACAO_DE_PROCEDENCIA_DE_INFORMACAO_VPI", 
        "CARTA_PRECATORIA_EXPEDIDA", "CARTA_PRECATORIA_RECEBIDA", "INTIMACAO"
    ]
    
    # Criar a tabela documentos
    execute_query("""
        CREATE TABLE IF NOT EXISTS documentos (
            id SERIAL PRIMARY KEY,
            tipo TEXT,
            numero TEXT UNIQUE,
            destino TEXT,
            data_emissao TEXT
        )
    """)
    
    # Criar as sequ√™ncias para cada tipo de documento
    for tipo in tipos:
        sequence_name = normalizar_nome(tipo)
        execute_query(f"CREATE SEQUENCE IF NOT EXISTS {sequence_name} START WITH 1 INCREMENT BY 1;")
        execute_query(f"ALTER SEQUENCE {sequence_name} OWNED BY documentos.id;")

# Chamar a fun√ß√£o para criar as tabelas e sequ√™ncias
create_tables()

def ensure_sequence(sequence_name):
    """Garante que a sequ√™ncia existe e est√° correta."""
    execute_query(f"""
        CREATE SEQUENCE IF NOT EXISTS {sequence_name}
        START WITH 1
        INCREMENT BY 1
        CACHE 1;
    """)

def get_next_number(tipo):
    """Gera o pr√≥ximo n√∫mero sequencial de um documento do tipo informado"""
    sequence_name = normalizar_nome(tipo)
    ensure_sequence(sequence_name)

    with get_db_connection() as conn:
        conn.set_session(autocommit=True)  # üöÄ Garante autocommit
        with conn.cursor() as cursor:
            cursor.execute(f"SELECT nextval('{sequence_name}')")  # Obt√©m pr√≥ximo n√∫mero
            count = cursor.fetchone()[0]

            numero = f"{count:03d}/{datetime.now().year}"  # Formata para 001/2025
            st.write(f"üîç Sequ√™ncia: {sequence_name}, N√∫mero Gerado: {numero}")

            # Verifica se esse n√∫mero j√° existe
            cursor.execute("SELECT 1 FROM documentos WHERE numero = %s", (numero,))
            exists = cursor.fetchone()

            if not exists:
                return numero  # ‚úÖ Retorna imediatamente!

    st.error("üö® Nenhum n√∫mero retornado (primeira tentativa falhou)!")
    return None

def save_document(tipo, destino, data_emissao):
    """Salva o documento gerando novo n√∫mero se houver conflito."""
    sequence_name = normalizar_nome(tipo)
    ensure_sequence(sequence_name)

    for tentativa in range(5):
        try:
            numero = get_next_number(tipo)
            if not numero:
                st.error("‚ùå get_next_number() retornou None!")
                return None

            # Formatar a data antes de inseri-la no banco
            data_emissao_formatada = formatar_data(data_emissao)
            if not data_emissao_formatada:
                st.error("üö® Formato de data inv√°lido. Use DD/MM/YYYY.")
                return None

            query = """
            INSERT INTO documentos (tipo, numero, destino, data_emissao)
            VALUES (%s, %s, %s, %s)
            ON CONFLICT (numero) DO UPDATE
            SET destino = EXCLUDED.destino
            RETURNING numero;
            """

            resultado = execute_query(query, (tipo, numero, destino, data_emissao_formatada), fetch=True)
            if resultado:
                st.success(f"‚úÖ Documento salvo: {resultado[0][0]}")
                return resultado[0][0]

            st.warning(f"‚ö†Ô∏è Conflito para n√∫mero {numero}, tentando novamente...")
        except psycopg2.IntegrityError:
            st.error("üö® Erro de integridade. Tentando novamente...")
            continue

    st.error("‚ùå Falha ap√≥s 5 tentativas.")
    return None


# Inicializa o estado de login
if "authenticated" not in st.session_state:
    st.session_state["authenticated"] = False

def login():
    st.sidebar.image("imagens/brasao.png", width=150)
    st.sidebar.markdown("## üîí Login")

    username = st.sidebar.text_input("Usu√°rio", key="login_user")
    password = st.sidebar.text_input("Senha", type="password", key="login_pass")

    if st.sidebar.button("Entrar", key="login_button"):
        correct_user = os.getenv("APP_USER", "DRITAPIPOCA")
        correct_password = os.getenv("APP_PASS", "Itapipoca2024")
        if username == correct_user and password == correct_password:
            st.session_state["authenticated"] = True
            st.rerun()
        else:
            st.sidebar.error("Usu√°rio ou senha incorretos!")

def main():
    if not st.session_state["authenticated"]:
        login()
    else:
        st.sidebar.image("imagens/brasao.png", width=150)
        st.sidebar.header("üìÑ Menu")
        menu = st.sidebar.selectbox("Escolha uma op√ß√£o", ["Gerar Documento", "Hist√≥rico", "Sair"], key="menu_select")

        if menu == "Gerar Documento":
            st.title("üìÑ Numerador de Documentos")

            with st.form("form_documento"):
                tipo = st.selectbox("üìå Tipo de Documento", [
                    "Oficio", "Protocolo", "Despacho", "Ordem de Missao", "Relatorio Policial",
                    "Verificacao de Procedencia de Informacao - VPI", "Carta Precatoria Expedida",
                    "Carta Precatoria Recebida", "Intimacao"
                ], key="doc_type")

                destino = st.text_input("‚úâÔ∏è Destino", key="doc_destino")
                data_emissao = datetime.today().strftime('%d/%m/%Y')
                st.text(f"üìÖ Data de Emiss√£o: {data_emissao}")

                submit_button = st.form_submit_button(label="‚úÖ Gerar N√∫mero")

            if submit_button:
                if destino.strip():
                    try:
                        numero = save_document(tipo, destino, data_emissao)
                        st.success(f"N√∫mero {numero} gerado com sucesso para o tipo {tipo}!")
                        st.code(numero, language="text")
                    except Exception as e:
                        st.error(f"Erro ao gerar n√∫mero: {e}")
                else:
                    st.error("Por favor, informe o destino.")

        if menu == "Hist√≥rico":
            st.title("üìú Hist√≥rico de Documentos")
            with get_db_connection() as conn:
                df = pd.read_sql_query("""
                    SELECT tipo, numero, data_emissao, destino 
                    FROM documentos
                    ORDER BY id DESC
                """, conn)

            if not df.empty:
                filtro_tipo = st.selectbox("Filtrar por Tipo", ["Todos"] + sorted(df['tipo'].unique()), key="filter_type")
                if filtro_tipo != "Todos":
                    df = df[df['tipo'] == filtro_tipo]

                filtro_data = st.date_input("Filtrar por Data", key="filter_date")
                if filtro_data:
                    df = df[df['data_emissao'] == filtro_data.strftime('%Y-%m-%d')]

                st.dataframe(df, height=300)
            else:
                st.warning("Nenhum documento encontrado.")

if __name__ == "__main__":
    main()
